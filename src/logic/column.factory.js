'use strict';
gantt.factory('GanttColumn', [ 'moment', function(moment) {
    // Used to display the Gantt grid and header.
    // The columns are generated by the column generator.

    var calcDbyP = function(column, maxDateValue, currentPosition) {
        return Math.round(maxDateValue / column.width * currentPosition / (maxDateValue / column.subScale)) * (maxDateValue / column.subScale);
    };

    var calcPbyD = function(column, date, maxDateValue, currentDateValue) {
        var factor;

        if (date - column.date > 0 && !column.containsDate(date)) {
            factor = 1;
        } else {
            factor = Math.round(currentDateValue / maxDateValue * column.subScale) / column.subScale;
        }

        return Math.round((column.left + column.width * factor) * 10) / 10;
    };

    var Column = function(date, left, width, subScale) {
        var self = this;
        self.date = date;
        self.left = left;
        self.width = width;
        self.subScale = subScale;

        self.getEndDate = function() {
            return self.getDateByPosition(self.width);
        };

        self.clone = function() {
            return new Column(self.date, self.left, self.width, self.subScale);
        };

        self.equals = function(other) {
            return self.date === other.date;
        };

    };

    var MonthColumn = function(date, left, width, subScale) {
        var column = new Column(moment(date), left, width, subScale);
        column.daysInMonth = column.date.daysInMonth();

        column.clone = function() {
            return new Column(moment(column.date), column.left, column.width, column.subScale);
        };

        column.containsDate = function(date) {
            return date.month() === column.date.month();
        };

        column.getDateByPosition = function(position) {
            if (position < 0) {
                position = 0;
            }
            if (position > column.width) {
                position = column.width;
            }

            var res = moment(column.date);
            res.date(1 + calcDbyP(column, column.daysInMonth, position));
            return res;
        };

        column.getPositionByDate = function(date) {
            return calcPbyD(column, date, column.daysInMonth, date.date());
        };

        return column;
    };

    var WeekColumn = function(date, left, width, subScale) {
        var column = new Column(moment(date), left, width, subScale);
        column.week = date.week();
        column.daysInWeek = 7;

        column.clone = function() {
            var copy = new Column(moment(column.date), column.left, column.width, column.subScale);
            copy.week = column.week;
            return copy;
        };

        column.containsDate = function(date) {
            return date.week() === column.date.week();
        };

        column.getDateByPosition = function(position) {
            if (position < 0) {
                position = 0;
            }
            if (position > column.width) {
                position = column.width;
            }

            var res = moment(column.date);
            var day = Math.round(calcDbyP(column, column.daysInWeek, position));

            res.day(day);
            return res;
        };

        column.getPositionByDate = function(date) {
            return calcPbyD(column, date, column.daysInWeek, date.day());
        };

        return column;
    };

    var DayColumn = function(date, left, width, subScale, isWeekend, daysToNextWorkingDay, daysToPrevWorkingDay, workHours, showNonWorkHours) {
        var column = new Column(moment(date), left, width, subScale);
        column.isWeekend = isWeekend;
        column.showNonWorkHours = showNonWorkHours;

        var startHour = 0;
        var endHour = 24;

        if (arguments.length === 9 && !showNonWorkHours && workHours.length > 1) {
            startHour = workHours[0];
            endHour = workHours[workHours.length - 1] + 1;
        }

        column.clone = function() {
            var copy = new Column(moment(column.date), column.left, column.width, column.subScale);
            copy.isWeekend = column.isWeekend;
            return copy;
        };

        column.containsDate = function(date) {
            return date.date() === column.date.date();
        };

        column.getDateByPosition = function(position, snapForward) {
            if (position < 0) {
                position = 0;
            }
            if (position > column.width) {
                position = column.width;
            }

            var res = moment(column.date);
            var hours = startHour + calcDbyP(column, (endHour - startHour), position);

            // Snap is done because a DAY can hide the non-work hours. If this is the case the start or end date of a task shall be the last work hour of the current day and not the next day.
            if (arguments.length === 2) {
                if (hours === endHour && snapForward) {
                    //We have snapped to the end of one day but this is a start of a task so it should snap to the start of the next displayed day
                    res.add(daysToNextWorkingDay, 'day');
                    hours = startHour;
                }
                else if (hours === startHour && !snapForward) {
                    //We have snapped to the start of one day but this is the end of a task so it should snap to the end of the previous displayed day
                    res.add(-daysToNextWorkingDay, 'day');
                    hours = endHour;
                }
            }

            res.hour(hours);
            return res;
        };

        column.getPositionByDate = function(date) {
            //first check that the date actually corresponds to this column
            //(it is possible that it might not if weekends are hidden, in which case this will be the nearest previous column)
            if (moment(date).startOf('day') > moment(column.date).startOf('day')) {
                return column.left + column.width;
            }
            if (moment(date).startOf('day') < moment(column.date).startOf('day')) {
                return column.left;
            }

            var maxDateValue = endHour - startHour;
            var currentDateValue = date.hour() - startHour;
            if (currentDateValue < 0) {
                return column.left;
            }
            else if (currentDateValue > maxDateValue) {
                return column.left + column.width;
            }
            else {
                return calcPbyD(column, date, maxDateValue, currentDateValue);
            }
        };

        return column;
    };

    var HourColumn = function(date, left, width, subScale, isWeekend, isWorkHour, hoursToNextWorkingDay, hoursToPrevWorkingDay) {
        var column = new Column(moment(date), left, width, subScale);
        column.isWeekend = isWeekend;
        column.isWorkHour = isWorkHour;

        column.clone = function() {
            var copy = new Column(moment(column.date), column.left, column.width, column.subScale);
            copy.isWeekend = column.isWeekend;
            copy.isWorkHour = column.isWorkHour;
            return copy;
        };

        column.containsDate = function(date) {
            return date.date() === column.date.date() && date.hour() === column.date.hour();
        };

        column.getDateByPosition = function(position, snapForward) {
            if (position < 0) {
                position = 0;
            }
            if (position > column.width) {
                position = column.width;
            }

            var res = moment(column.date);
            var minutes = calcDbyP(column, 60, position);

            // Snap is done because a HOUR can hide the non-work hours. If this is the case the start or end date of a task shall be the last work hour of the current day and not the next day.
            if (arguments.length === 2) {
                if (minutes === 60 && snapForward) {
                    //We have snapped to the end of one day but this is a start of a task so it should snap to the start of the next displayed day
                    res.add(hoursToNextWorkingDay, 'hours');
                    minutes = 0;
                }
                else if (minutes === 0 && !snapForward) {
                    //We have snapped to the start of one day but this is the end of a task so it should snap to the end of the previous displayed day
                    res.add(-hoursToPrevWorkingDay, 'hours');
                    minutes = 60;
                }
            }

            res.minutes(minutes);
            return res;
        };

        column.getPositionByDate = function(date) {
            if (moment(date).startOf('day') > moment(column.date).startOf('day')) {
                return column.left + column.width;
            }

            return calcPbyD(column, date, 60, date.minutes());
        };

        return column;
    };

    return {
        Hour: HourColumn,
        Day: DayColumn,
        Week: WeekColumn,
        Month: MonthColumn
    };
}]);
